{
  "keyboard_shortcut": "", 
  "name": "markdownFormatter", 
  "language": "JavaScript", 
  "trigger": "trigger_startup", 
  "value": [
    "/** Merge includes in markdown file", 
    " *", 
    " * Edited file must has name '-source.md'\tE.G: 'readme-source.md'", 
    " * Compiled file has suffix removed\tE.G: 'readme.md'", 
    " *", 
    " * INCLUDE SYNTAX:", 
    " * \t\t{include:relative\\path} ", 
    " * \tE.G:\t{include:\\Documentation\\controls\\controls-items\\controls-items.ahk} ", 
    " * ", 
    " */", 
    "", 
    "if( typeof ko.extensions.vilbur === 'undefined'  )", 
    "\tko.extensions.vilbur = {};", 
    "\t", 
    "", 
    "ko.extensions.vilbur.markdownFormatter = function()", 
    "{", 
    "\t", 
    "\t//var Logger\t= ko.extensions.Logger_v3 ? new ko.extensions.Logger_v3(this).clear(false).off(false) : require('ko/console');", 
    "\tvar koEditor\t= require(\"ko/editor\");", 
    "\tvar koFile\t= require(\"ko/file\");", 
    "\tvar koFileEx\t= Components.classes[\"@activestate.com/koFileEx;1\"].createInstance(Components.interfaces.koIFileEx);", 
    "", 
    "\t", 
    "\tvar current_file\t= ko.views.manager.currentView.koDoc.file.path;", 
    "\tvar current_dir\t= koFile.dirname(current_file);", 
    "\t//var file_content\t= koEditor.getValue();", 
    "\tvar file_content\t= removeEmptyEverySecondLine(koEditor.getValue());", 
    "\t", 
    "\t/* ECTENSIONS ALLOWED TO BE INCLUDED */ ", 
    "\tvar allowed_extensions\t= /(komodotool|ktf|md|ahk|php|js|html|xul|ms)/gi; // allowed extension for including IMPORTANT: Add new extension to getLang() method", 
    "", 
    "\t/* DO NOT INCLUDE - links preceded by exclude_character */ ", 
    "\tvar exclude_characters = ';//';", 
    "", 
    "\t/* ========= FIND ALL OCCURENCES OF \"inlcudes\" ========= */", 
    "", 
    "\t", 
    "\t\t\t//file_content.match( new RegExp( '/[^'+exclude_characters+']/', 'gi') ) ", 
    "\t//var includes\t= file_content.match( new RegExp( '/'+exclude_characters+'*\\\\[include:.*\\\\]/', 'gi') ) ", 
    "", 
    "\t//var includes\t= file_content.match(/;*\\[include:.*\\]/gi);", 
    "\tvar includes\t= file_content.match(/\\[include:[^\\]]*\\]\\([^)]+\\)/gi);", 
    "", 
    "\t/* EXIT IF included file has not allowed extension */ ", 
    "\tif ( current_file.match(/-source.md$/gi) == null  )", 
    "\t\treturn;", 
    "", 
    "\t/** file read add empty line below every line", 
    "\t */", 
    "\tfunction removeEmptyEverySecondLine(string)", 
    "\t{", 
    "\t\t//return string.replace(/^/gm, '~~~').replace(/~~~\\n~~~/gm, '~~~').replace(/~~~/gm, '');", 
    "\t\treturn string", 
    "\t\t\t.replace(/^/gm, '~~~')", 
    "\t\t\t.replace(/~~~\\n~~~/gm, '~~~')", 
    "\t\t\t.replace(/~~~/gm, '');\t\t", 
    "\t}", 
    "\t\t", 
    "\t/** get icluded file content and wraop to codeblock", 
    "\t */", 
    "\tfunction getIncludeContent(path)", 
    "\t{", 
    "\t\t", 
    "\t\t/** Include *.ahk file", 
    "\t\t */", 
    "\t\tthis.include_ahk = function(file_content)", 
    "\t\t{", 
    "\t\t\t/** remove line starts with #", 
    "\t\t\t */", 
    "\t\t\tfunction removeDirectives()", 
    "\t\t\t{", 
    "\t\t\t\t//return string.replace(/#.*([\\r\\n]|$)/gmi, '');", 
    "\t\t\t\tfile_content = file_content.replace(/#.*([\\r\\n]+|$)/gmi, '');\t\t\t\t", 
    "\t\t\t}", 
    "\t\t\t/** remove lines with commented autohotkey dump E.G.: \";;;Dump(...)\"", 
    "\t\t\t */", 
    "\t\t\tfunction removeDumps()", 
    "\t\t\t{", 
    "\t\t\t\tfile_content = file_content.replace(/[\\r\\n]\\s*;+\\s*Dump.*([\\r\\n]|$)/gmi, '');\t\t", 
    "\t\t\t}", 
    "\t\t\t", 
    "\t\t\tremoveDirectives();", 
    "\t\t\tremoveDumps();", 
    "\t\t\t", 
    "\t\t\treturn removeEmptyEverySecondLine(file_content).replace(/^\\s+/gi, '');", 
    "\t\t};", 
    "\t\t", 
    "\t\t/** Include *.komodotool file", 
    "\t\t */", 
    "\t\tthis.include_komodotool = function(file_content)", 
    "\t\t{", 
    "\t\t\t/* PARSE JSON TO TEXT - komodotool  */ ", 
    "\t\t\tvar file_content_obj\t= JSON.parse(file_content);", 
    "", 
    "\t\t\tvar value\t= file_content_obj.value;", 
    "\t\t", 
    "\t\t\treturn value.join('\\n').trim();", 
    "", 
    "\t\t};", 
    "\t\t", 
    "\t\t/** Include komodotool *.ktf file", 
    "\t\t */", 
    "\t\tthis.include_ktf = function(file_content)", 
    "\t\t{", 
    "\t\t\t/* Remove block comment from start of string, */ ", 
    "\t\t\tfile_content = file_content.replace(/^\\s*\\/\\*[\\s\\S]*?\\*\\/\\s*/, '');", 
    "", 
    "\t\t\treturn removeEmptyEverySecondLine(file_content);", 
    "\t\t};", 
    "\t\t", 
    "\t\t/** Include *.ms file", 
    "\t\t */", 
    "\t\tthis.include_ms = function(file_content)", 
    "\t\t{", 
    "\t\t\tfile_content = file_content.replace(/^(filein|clearListener).*$[\\r\\n]*/gmi, '');\t\t\t\t", 
    "", 
    "\t\t\t//var file_content_obj\t= JSON.parse(file_content); ", 
    "\t\t\t//var value\t= file_content_obj.value;", 
    "\t\t\t", 
    "\t\t\treturn removeEmptyEverySecondLine(file_content);", 
    "\t\t};", 
    "", 
    "\t\t/** Include *.ms file", 
    "\t\t */", 
    "\t\tthis.include_md = function(file_content)", 
    "\t\t{", 
    "\t\t\t//file_content = file_content.replace(/^(filein|clearListener).*$[\\r\\n]*/gmi, '');\t\t\t\t", 
    "", 
    "\t\t\t//var file_content_obj\t= JSON.parse(file_content); ", 
    "\t\t\t//var value\t= file_content_obj.value;", 
    "\t\t\t", 
    "\t\t\treturn file_content;", 
    "\t\t};", 
    "\t\t", 
    "\t\t/** get language by file extension", 
    "\t\t */", 
    "\t\tvar getLang = function(_extension)", 
    "\t\t{", 
    "\t\t\tswitch (_extension) {", 
    "\t\t\t\tcase 'md':", 
    "\t\t\t\t\treturn \"markdown\";", 
    "\t\t\t\t", 
    "\t\t\t\tcase 'ahk':", 
    "\t\t\t\t\treturn \"php\";", 
    "\t\t\t\t", 
    "\t\t\t\tcase 'ms':", 
    "\t\t\t\t\treturn \"maxscript\";", 
    "\t\t\t", 
    "\t\t\t\tcase 'js':", 
    "\t\t\t\t\t", 
    "\t\t\t\tcase 'komodotool':", 
    "\t\t\t\t\treturn \"javascript\";", 
    "\t\t\t\t\t", 
    "\t\t\t\tcase 'ktf':", 
    "\t\t\t\t\treturn \"javascript\";", 
    "\t\t\t\t", 
    "\t\t\t\tcase 'html':", 
    "\t\t\t\t\t", 
    "\t\t\t\tcase 'xul':", 
    "\t\t\t\t\treturn \"xml\";\t\t\t\t\t", 
    "\t\t\t\t", 
    "\t\t\t\tdefault:\treturn _extension;", 
    "\t\t\t}", 
    "\t\t};", 
    "\t\t", 
    "\t\t/** Extensin is allowed", 
    "\t\t */", 
    "\t\tvar extension = (function()", 
    "\t\t{", 
    "\t\t\t\t", 
    "\t\t\tvar extension_match = allowed_extensions.exec(path);", 
    "\t\t\t", 
    "\t\t\tallowed_extensions.lastIndex = 0; // reset regEx for next use", 
    "\t\t\t//console.log(  'extension_match: ' + extension_match );", 
    "", 
    "\t\t\tif( ! extension_match ){", 
    "\t\t\t\tvar file_current_extension\t= koFile.basename(path).split(/\\./g).pop();", 
    "\t\t\t\t", 
    "\t\t\t\t", 
    "\t\t\t\talert( 'markdownFormatter:\\n\\tUnsupported extension: *.'+file_current_extension + \"\\n\\nADD EXTESNTION TO:\\n\\tmarkdownFormatter.allowed_extensions\");  ", 
    "\t\t\t\treturn false;", 
    "\t\t\t", 
    "\t\t\t}", 
    "\t\t\t//console.log(  'extension_match: ' + extension_match );", 
    "\t\t\t", 
    "\t\t\tvar extension = extension_match.pop();", 
    "\t\t", 
    "\t\t\treturn extension.toLowerCase();;", 
    "\t\t})(); ", 
    "\t\t", 
    "", 
    "\t\t", 
    "\t\tif( ! extension )", 
    "\t\t\treturn;", 
    "\t\t", 
    "\t\t/* INCLUDE BY FILEYPE", 
    "\t\t *", 
    "\t\t */", 
    "\t\tvar path_include = current_dir + path;", 
    "\t\t", 
    "\t\tif( ! koFile.exists(path_include))", 
    "\t\t\treturn \"[\"+path+\"](\"+path+\")\"; // return relative link if file does not exists", 
    "\t\t", 
    "\t\tvar file_content\t = koFile.read(path_include);", 
    "\t\t", 
    "\t\tvar method = 'include_'+ extension;\t", 
    "\t\t", 
    "\t\tvar include_content\t= this[method] ? this[method](file_content) : removeEmptyEverySecondLine(file_content);", 
    "", 
    "\t\t", 
    "\t\tif ( extension.match(/\\.md$/gi) )", 
    "\t\t\treturn include_content;", 
    "", 
    "\t\telse", 
    "\t\t\treturn '\\n``` '+getLang(extension)+'\\n'+include_content+'\\n```';", 
    "\t}", 
    "\t", 
    "\t/*", 
    "\t*/ ", 
    "\tfunction writeToFile(path, content)", 
    "\t{", 
    "\t\t", 
    "\t\t//koFile.create( path, content, true );", 
    "\t\t//koFile.create( path, '# content', true );", 
    "\t\t", 
    "\t\tif(koFile.exists(path))", 
    "\t\t\tkoFile.remove(path);", 
    "\t\t\t", 
    "\t\tkoFile.create( path ); ", 
    "\t\tkoFileEx.path = path;  ", 
    "\t\tkoFileEx.open(\"w\");", 
    "\t\tkoFileEx.puts(content);", 
    "\t\tkoFileEx.close();", 
    "\t}", 
    "\t", 
    "\t/** Escape for Markdown synatax", 
    "\t */", 
    "\tvar escapeContent = function(string)", 
    "\t{", 
    "\t\treturn string", 
    "\t\t\t\t.replace(/(\\w)\\|(\\w)\\|*/gi, '$1\\\\|$2') // sanitize \"|\" pipe E.G.: \"A|B\"", 
    "\t\t\t\t.replace(/\\t/gi, '    ');", 
    "\t\t\t\t//.replace(/\\|/gi, '$1!\\\\|$2') // sanitize \"|\" pipe E.G.: \"A|B\"\t\t\t\t", 
    "\t}; ", 
    "\t", 
    "\t/*", 
    "\t*/ ", 
    "\tfunction replaceSpacesInFileTree(text)", 
    "\t{", 
    "\t\tvar regex_start_line = /\\n {4}(?: {4})*/g;", 
    "\t\t", 
    "\t\ttext = text.replace(regex_start_line, match => {", 
    "\t\t\t// Count spaces (ignore the \\n)", 
    "\t\t\tconst spaces = match.length - 1;", 
    "\t\t\treturn \"\\n\" + \" &nbsp;\".repeat(spaces);", 
    "\t\t});", 
    "\t\t", 
    "\t\tconst regex_brach_pipe = /\\| {3}(?: {3})*/g;", 
    "\t\t", 
    "\t\ttext = text.replace(regex_brach_pipe, match => {", 
    "\t\t\t// Count spaces (ignore the \\n)", 
    "\t\t\tconst spaces = match.length - 1;", 
    "", 
    "\t\t\t//return \"|\" + \"&nbsp;\".repeat(spaces);", 
    "\t\t\treturn \"|\" + \" &nbsp;\".repeat(spaces);", 
    "\t\t});", 
    "\t\t", 
    "\t\treturn text;", 
    "\t}", 
    "\t", 
    "\t///*", 
    "\t//*\tfrom_path = \"C:/data/project_a/images\"", 
    "\t//*\tto_path   = \"C:\\data\\project_a\\docs\\readme.md\"", 
    "\t//*", 
    "\t//*\t@return string relative path E.G.: '../docs/readme.png'", 
    "\t//*", 
    "\t//*/", 
    "\t//var _getRelativePath = function(from_path, to_path)", 
    "\t//{", 
    "\t//\t", 
    "\t//\tfrom_path = from_path.replace( /[\\/\\\\]+/g, '\\\\' );", 
    "\t//\tto_path   = to_path.replace( /[\\/\\\\]+/g, '\\\\' );", 
    "\t//", 
    "\t//\tvar nsFileFrom = Components.classes[\"@mozilla.org/file/local;1\"].createInstance(Components.interfaces.nsILocalFile);", 
    "\t//\t ", 
    "\t//\t console.log(  ''  );", 
    "\t//\t console.log(  'from_path: ' + from_path  );", 
    "\t//\t console.log(  'to_path: ' + to_path  );", 
    "\t//\t", 
    "\t//\tnsFileFrom.initWithPath(from_path);", 
    "\t//\t", 
    "\t//\tvar nsFileTo = Components.classes[\"@mozilla.org/file/local;1\"].createInstance(Components.interfaces.nsILocalFile);", 
    "\t//\t", 
    "\t//\tnsFileTo.initWithPath(to_path);", 
    "\t//\t", 
    "\t//\treturn nsFileTo.getRelativeDescriptor(nsFileFrom);", 
    "\t//};", 
    "\t", 
    "\t/* Escape readme content wihtout included scripts", 
    "\t **/", 
    "\t//file_content =  escapeContent(file_content);", 
    "    //console.log(  'file_content: ' + file_content );", 
    "\t//file_content =  escapeUnicode(file_content);", 
    "\tfile_content =  replaceSpacesInFileTree(file_content);", 
    "", 
    "\t/**", 
    "\t */", 
    "\tif( includes )", 
    "\t", 
    "\t\t/* LOOP EACH LINK TO INCLUDE */ ", 
    "\t\tfor(var i=0; i<includes.length;i++)", 
    "\t\t\t//console.log(  'INCLUDE: ' + includes[i] );", 
    "\t\t", 
    "\t\t\t/* IF LINK IS NOT ESCAPED - E.G.: ;[] */ ", 
    "\t\t\tif ( ! includes[i].match( new RegExp( '^['+exclude_characters+']+', 'gi') ) )", 
    "\t\t\t{", 
    "\t\t\t\t", 
    "\t\t\t\t/* GET ONLY PATH FROM LINK */ ", 
    "\t\t\t\tvar path_relative = new RegExp(/\\[include:.*\\]\\(\\s*(.*)\\s*\\)/gi).exec(includes[i]).pop();", 
    "\t\t\t\t", 
    "\t\t\t\tvar path_absolute =  current_dir + path_relative", 
    "\t\t\t\t", 
    "\t\t\t\tconsole.log(  'path_absolute: ' + path_absolute );", 
    "\t\t\t\tconsole.log(  'path_absolute: ' + koFile.exists(path_absolute) );", 
    "\t\t\t", 
    "\t\t\t\t/* ========= REPLACE IN FILE  ========= */", 
    "\t\t\t\t", 
    "\t\t\t\tif( koFile.exists(path_absolute) )", 
    "\t\t\t\t\tfile_content = file_content.replace( includes[i], getIncludeContent(path_relative) );", 
    "\t\t\t}", 
    "\t\t\telse", 
    "\t\t\t\tconsole.log(  'Include escaped: ' + includes[i] );", 
    "\t", 
    "\t", 
    "\t/* REMOVE SUFFIX FOR FINAL FILENAME */ ", 
    "\tfile_path = current_file.replace(/-source.md$/gi, '.md');", 
    "", 
    "\t/* WRITE COMPILED CONTENT TO NEW FILE */ ", 
    "\twriteToFile( file_path, file_content );", 
    "\t", 
    "};", 
    "", 
    "", 
    "/* TEST */", 
    "ko.extensions.vilbur.markdownFormatter();"
  ], 
  "version": "1.1.5", 
  "rank": 100, 
  "trigger_enabled": 1, 
  "async": 1, 
  "type": "macro"
}