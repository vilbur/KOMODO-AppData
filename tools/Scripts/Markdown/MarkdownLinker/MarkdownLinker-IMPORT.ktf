/*
komodo tool: MarkdownLinker-IMPORT
==================================
async: 0
is_clean: true
language: JavaScript
rank: 100
trigger: trigger_postopen
trigger_enabled: 0
type: macro
version: 1.1.5
==================================*/
if( typeof ko.extensions.vilbur === 'undefined' )
	ko.extensions.vilbur = {};
	
if( typeof ko.extensions.vilbur.markdown === 'undefined' )
	ko.extensions.vilbur.markdown = {};

/** Search in tree of current file, and write links to files matching criteria
 *
 * @method	self	searchName( string search_name )	Search file name	DEFAULT: '.*'
 * @method	self	searchExt( string file_ext )	Search file extension	DEFAULT: 'php|ahk|js'
 * @method	self	matchDirName( boolean|string match )	Search only files which name is same as folder name E.G.: "FooBar\FooBar.php"	DEFAULT: false
 * 
 * @method	self	maxLevel( int max_level )	Set depth of tree for searching	DEFAULT: unlimited
 *
 * @method	self	linkToDir( boolean link )	Set link to dir E.G.: "\dir\subdir\file.*" >>> "\dir\subdir"	DEFAULT: false
 * @method	self	textBy( string display )	Set text of link by sanitized filename or directory*	DEFAULT: 'dir'
 * @method	self	indentation( boolean|string indentation )	Set indentation of links by directory tree*	DEFAULT: false
 * @method	self	codeBlock( boolean code_block)	Link is included as codeblock E.G.: [include:\dir\file.komodotool] 	DEFAULT: false
 *
 * @method	self	heading( string heading )	Set heading above included block	DEFAULT: ''
 * @method	self	update( boolean update )	Update mode will update existing section, heading must be set	DEFAULT: true
 * @method	self	unique( boolean unique )	Include only if not in file content already	DEFAULT: false
 * 
 * @method	void	include()	Include matching files as links
 */
ko.extensions.vilbur.markdown.MarkdownLinker = (function()
{
	var komodo_view = komodo.view;
	
	function MarkdownLinker()
	{
		var Logger	= ko.extensions.Logger_v3 ? new ko.extensions.Logger_v3(this).clear(true).off(false) : require('ko/console');
		var initialized	= false;
		
		var koFile	= require("ko/file");
		var koEditor	= require("ko/editor");
		var scimoz	= ko.views.manager.currentView.scimoz; 
		var current_file	= ko.views.manager.currentView.koDoc.file.path;
		var current_dir	= koFile.dirname(current_file);
		var file_content	= koEditor.getValue();
		
		var include_lines	= [];

		/* Search options */
		var search_extensions	= /\.(php|ahk|js|md)$/gi; // these extensions is used for auto find extension
		var search_ext	= '';
		var search_name	= '.*';				
		var match_dir_name	= false;
		
		/* TYPES OF INCLUDED CONTETN */ 
		var rx_file_types = {
			image:	/\.(jpg|png|jpg)$/gi,
			markdown:	/\.(md)$/gi,
			codeblock:	search_extensions,
		};
						
		/* Tree options */
		var max_level	= null;
		
		/* Write options */
		var link	= true;
		var display	= 'name';
		var indentation	= false;
		var tree	= false;
        //var prefix = '-';
		var code_block	= false;
		var update	= true;
		var unique	= false;
		var heading	= '';
			
		/* result array
		 */
		var match_files	= [];
		
		/* DEVELOPMENT */ 
		var developmentPrint = function(dir_tree, level = 0 )
		{
			for(var path in dir_tree)
			{
				//console.log( path + ': ' + dir_tree[path] );
				if( typeof dir_tree[path] === "object" )
					developmentPrint(dir_tree[path], level++ );
				
			}
		};
		
		/* ========= SEARCH OPTIONS ========= */

		/** Search file name
		 * @param	string	search_name	File name for search
		 * @return	self
		 */
		this.searchName = function(_search_name)
		{
			search_name = _search_name;
			return this; 
		}; 
		
		/** Set search_ext for search match
		 *
		 * @param	string	search_ext	extension searched in dirs E.G.: 'php|md'
		 * @return	self
		 */
		this.searchExt = function(_file_ext)
		{
			search_ext = _file_ext;
			return this; 
		};
		/** Search only files which name is same as folder name E.G.: "FooBar\FooBar.php"
		 * @param	string|boolean	match	If TRUE, then full match is searched, If anything else, folder name with any suffix E.G.: 'FolderName-any-suffix.jpg'
		 * @return	self
		 */
		this.matchDirName = function(match=true)
		{
			match_dir_name = match;
			return this;
		};
		/*---------------------------------------
			TREE OPTIONS
		-----------------------------------------
		*/
		/** Set depth of tree for searching
		 * Default is unlimited levels
		 * 
		 * @param	int	max_level	Max level of tree E.g.: max_level=0 // search only current dir, max_level=1 search only 1 subdir
		 * @return	self
		 */
		this.maxLevel = function(_max_level)
		{
			//max_level = _max_level +1;
			max_level = _max_level;
			return this;
		};
		
		/* ================ WRITE OPTIONS ================ */

		/** Set link to dir E.G.: "\dir\subdir\file.*" >>> "\dir\subdir"
		 *
		 * @param	boolean 	link
		 * @return	this 
		 */
		this.link = function(_link=true)
		{
			link = link;
			return this;
		};

		/** Set indentation of links by directory tree
		 *
		 * @param	boolean|string	
		 * @return	this 
		 */
		this.indentation = function( _indentation = true )
		{
			if(initialized)
				indentation = _indentation;
			//indentation = _indentation === true ? '\t' : (indentation==' ' ? '  ' : _indentation); // prevent only 1 whitespace, 2 spaces are minimum
			return this;
		};
		/*
		*/ 
		this.showTree  = function( _tree = true )
		{
			if(initialized)
				tree = _tree;
			return this;
		};
		/** Set text of link by sanitized filename or directory
		 * Default is by dir
		 *
		 * @param	string	display
		 * @return	this 
		 */
		this.display = function(_display='')
		{
			display = _display;
			return this;
		};
 
		/** Set heading above included block
		 * @param	string	heading
		 * @return	self
		 */
		this.heading = function(_heading='')
		{
			heading = _heading;
			return this;
		};

		/** Include only if not in file content already
		 *
		 * @param	boolean	unique
		 * @return	this 
		 */
		this.unique = function(_unique=true)
		{
			unique = _unique;
			return this;
		};

		/** Link is included as codeblock E.G.: [include:\dir\file.komodotool]  
		 *  Include is treated with markdownFormatter.komodotool
		 *
		 * @param	boolean	code_block
		 * @return	this 
		 */
		this.codeBlock = function(_code_block=true)
		{
			code_block = _code_block;
			return this;
		};

		/** Update mode will update existing section
		 *	Section start with heading and end on next heading
		 *	Heading must be set
		 * 
		 * @param	string	pdate
		 * @return	this 
		 */
		this.update = function(_update=true)
		{
			update = _update;
			return this;
		};
		/**
		 * Convert nested object to 2D matrix
		 * Each row is a path to a leaf value
		 * Columns = maximum depth
		 */
		function objectToMatrix(obj) {
			let rows = [];
			let maxDepth = 0;
		
			function traverse(node, path) {
				if (node !== null && typeof node === "object" && !Array.isArray(node)) {
					for (let key in node)
					{
						if (node.hasOwnProperty(key)) 
						traverse(node[key], [...path, key]);
					}
				} else {
					//rows.push([...path, node]);
					rows.push([...path, node]);
					maxDepth = Math.max(maxDepth, path.length + 1); // +1 includes value column
				}
			}
		
			traverse(obj, []);
		
			// Normalize rows to have equal column count
			let matrix = rows.map(row => {
				let padded = [...row];
				
				while (padded.length < maxDepth) padded.push(null);
				
				return padded;
			});
		
			return matrix;
		}

		/* ================ INCLUDE ================ */
		
		/** Include matching files as links
		 */
		this.include = function()
		{

			/*------ GET DIRECTORY TREE ------
			 */
			var getDirectoryTree = function(path, level = 0 )
			{
				/** Get subdirs in dir
				 */
				var getSubDirs = function(path)
				{
					return koFile.list(path).filter(function(dir){
									return ! koFile.isFile(path+'\\'+dir);
								});
				};
				/** Get files in dir
				  */
				var getFiles = function(path)
				{
					return koFile.list(path).filter(function(dir){
									return koFile.isFile(path+'\\'+dir);
								});
				};
				
				var subdirs	= getSubDirs(path);
				var files	= getFiles(path);
				var dirs_and_files	= {};

				//Logger.info(level >= max_level, 'MarkdownLinker: '+'level >= max_level'); 
				if( max_level && level == max_level )
					return; 
				
				/* IF ANY SUBDIR EXISTS */ 
				if( subdirs.length )
				{
					depth_added = level++;
					
					/*------ ADD SUBDIRS ------*/
					for(var d=0; d<subdirs.length;d++)
						dirs_and_files[subdirs[d]] = getDirectoryTree( path+'\\'+subdirs[d], level); 
				}

				/*------ ADD FILES ------*/
				for( var index in files )
					if (files.hasOwnProperty(index))
						//dirs_and_files[index] = 'WTF';
						dirs_and_files[index] = files[index];
				
				/* RETURN SUBDIRS and FILES if any exists */
				return Object.keys(dirs_and_files).length ? dirs_and_files : null;
			
			};
			
			/*------ SEARCH IN SUBDIRS FOR FILES matching criteria ------
			 */
			var searchForFiles = function(_dir_path, dir_tree)
			{

				/** filterFilesByExtension
				*/
				var filterFilesByExtension = function(_dir_path)
				{
				   /** Find matching file type in files by search_extensions
					*/
				   var findFileExt = function(_dir_path)
				   {
					   koFile.list(_dir_path).map(function(file){
						   
						   var file_match = search_extensions.exec(_dir_path+'\\'+file);
						   
						   if (file_match)
							   search_ext = file_match.pop();
						   //Logger.info(search_ext, 'MarkdownLinker: '+'search_ext'); 
					   }); 
				   }; 
					   
				   /* FIND EXTENSION AUTOMATICALY */ 
				   if( ! search_ext )
					   findFileExt(_dir_path);
				   
				   /* LOOP EACH FILE IN DIRECOTRY */ 
				   koFile.list(_dir_path).map(function(name)
				   {
					   
					   var file_path	= _dir_path +'\\'+ name;
				
						console.log(  'file: ' + file_path );

					   if (file_path != current_file)
					   {
						   if( match_dir_name )
							   search_name = koFile.basename(_dir_path) + (match_dir_name===true ? '' : '.*');
						   //Logger.info(search_ext, 'MarkdownLinker: '+'search_ext');
						   //Logger.info(search_name, 'MarkdownLinker: '+'search_name');						
						   //Logger.info( new RegExp(search_name+'\.('+search_ext+')$', 'gi').exec(name) , 'match: '+name); 
						   
						   if( new RegExp( '^'+search_name+'\.('+search_ext+')$', 'gi').exec(name) )
							   match_files.push(file_path);
					   }
				   });
				};
				
				/** REMOVE EMPTY DIRS
				 */
				var removeEmptyDirs = function(dirs)
				{
					return dirs.filter(function(dir){
						return dir.length;
					});
				};
				
				/*------ SEARCH FOR FILES ------*/
	
				return removeEmptyDirs(match_files); 
			};
				/** getIndentation
			 */
			//var getIndentation = function(indent_count, is_directory, is_last = false )
			//{
			//	//console.log(  'indentation: ' + indentation );
			//	
			//	if( is_last )
			//		prefix = '|___' ;
			//	else
			//		prefix = is_directory ? '|---' : '|   ';
			//	 
			//	
			//	
			//	
			//	return ! indentation ? Array(indent_count - 1).join('    ') + prefix : '';
			//	 
			//}; 			
				
	
			/*------ GET  ------*/
			var dir_tree = getDirectoryTree(current_dir);
			
			developmentPrint( dir_tree ) ;
			
	
			function printTree(obj, prefix = "", relPath = "")
			{
				/*
				*/ 
				var getIndentation = function( is_branch, is_last, _prefix = '' )
				{
					if(tree)
					{
						if( is_branch )
							return  is_last ? "|___ " : "|--- ";
						
						else
							return  _prefix + (is_last ? '    ' : '|   ');
					}
					else
						return indentation ? _prefix + '    ' : '';
				};
				
				/** setInlcudeFile
				 */
				var setInlcudeFile = function( text, path, prefix )
				{
					
					/** Get link text by dir name or sanitized filename file
					 * Filename is sanitized by replacing '-_' with space
					 *
					 * @return	string	Text of link
					 */
					var getLinkText = function(path)
					{
						if( display=='dir' )
							return koFile.basename(koFile.dirname(path));
						
						var filename	= koFile.basename(path).split('.').shift().replace(/[-|_]/gi, ' ');
						
						return  filename.charAt(0).toUpperCase() + filename.slice(1);
					};
					/** findIncludeFileType
					 */
					//var findIncludeFileType = function()
					//{
					//	for(var file_type in rx_file_types)
					//		if (rx_file_types.hasOwnProperty(file_type))
					//			if( path.match(rx_file_types[file_type]) )
					//				return file_type;
					//};
					
					/** getCodeblockLink
					 */
					var getCodeblockLink = function()
					{
						return '[include:\\'+_getRelativePath(current_dir, path).replace(/\//g, '\\') +']';
					}; 
					/** getFileLink
					 */
					var getFileLink = function(include_type)
                    {
						var prefix_for_image = include_type==='image' ? '!' : '';
						
						var path_to	= link ? koFile.dirname(path) : path;
						
						return prefix_for_image+'['+getLinkText(path)+']('+_getRelativePath(current_dir, path_to)+')';
					};
					/** setLinkToIncludes
					 */
					var setLinkToIncludes = function(link)
					{

						
						if( _isNotInFile(link) )
							include_lines.push( getIndentation(indent_count, false, is_last ) + link );
					}; 

					//var include_type = findIncludeFileType();
					//setLinkToIncludes( code_block && include_type=='codeblock'? getCodeblockLink() :getFileLink() );

					include_lines.push( prefix + text + path );

				};
			  
				/* ========= ITERATE TREE ========= */
				const keys = Object.keys(obj);
					  
				keys.forEach((name, index) => {
							
					const is_last = index === keys.length - 1;
					
					const prefix_branch = getIndentation( true, is_last );
							
					/*------ DIRECTORY ------*/
					if (isNaN(name))
					{
						const dir_path = relPath ? relPath + '\\' + name : name;
						//const dir_path = '\\' + (relPath ? relPath + '\\' + name : name);
								  
						var file_count = Object.keys(obj[name]).length;

						//var dir_path = '(' + dir_path + '/)'
						var line_prefix = prefix + prefix_branch;
						
						//line_prefix += ' \\'+dir_path;
						//var line_prefix = prefix + branch + name //+ '/ [' + file_count + ' files]   ;
						
						//include_lines.push(name);
						setInlcudeFile( name, dir_path, line_prefix );
		
						//const new_prefix = prefix + (is_last ? '    ' : '|   ');
						const new_prefix = getIndentation( false, is_last, prefix );
						
						printTree(obj[name], new_prefix, dir_path);
					}
					
					/*------ FILE ------*/ 
					else
					{
						var line_prefix = prefix + prefix_branch;
								  
						var file_path = relPath ? relPath + '\\' + obj[name] : obj[name];
						//var file_path = '\\' + (relPath ? relPath + '\\' + obj[name] : obj[name]);
					
						var file_name = obj[name];
						//include_lines.push(obj[name]);
						setInlcudeFile( file_name, file_path, line_prefix );
					}
				});
			}
			
			console.log(  'tree: ' + tree );
			console.log(  'indentation: ' + indentation );


			//addMarkdownSyntax(dir_tree, 0);
			printTree(dir_tree);
			
			/*------ WRITE TO FILE ------*/
			writeToFile();
			
			
			
			//Logger.info(include_lines, 'MarkdownLinker: '+'include_lines'); 
		};

		/* ================ PRIVATE ================ */


		/** rx_escaped_string
		 */
		var _escapedRegexString = function(string)
		{
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g,'\\s+'); // $& means the whole matched string
		};
		
		/** _isNotInFile
		 */
		var _isNotInFile = function(string)
		{
			return file_content.match( new RegExp(_escapedRegexString(string), 'gi') )===null || ! unique || update;
		};
		
		/**
		 *
		 */
		var _getRelativePath = function(fromPath, toPath)
		{
			var nsFileFrom = Components.classes["@mozilla.org/file/local;1"]
								  .createInstance(Components.interfaces.nsILocalFile);
			nsFileFrom.initWithPath(fromPath);
			var nsFileTo = Components.classes["@mozilla.org/file/local;1"]
								  .createInstance(Components.interfaces.nsILocalFile);
			nsFileTo.initWithPath(toPath);
			return nsFileTo.getRelativeDescriptor(nsFileFrom);
		};
		
		/** writeToFile
		 */
		var writeToFile = function()
		{
			/** _updateContent
			 */
			var _updateContent = function()
			{
				/** getHeadings
				 */
				var getHeadings = function()
				{
					return heading ? '## '+heading+'\n' : '';
				};
				
				/** Update mode will update existing section
				 *	Section will be searched from heading up to next heading
				 *
				 * @return	{start: int, end: int}
				 */
				var getUpdatePosition = function()
				{
					var heading_match	= new RegExp( _escapedRegexString(getHeadings()) + '[^#]+', 'gmi').exec(file_content); 
					if( ! update || ! heading_match  )
						return null;
	
					//Logger.info(heading_match, 'MarkdownLinker: '+'heading_match'); 
					return { 'start': heading_match.index, 'end':  heading_match.index + heading_match[0].length };		
				};
	
				/** replaceRange
				 */
				var replaceRange = function(update_pos)
				{
					//alert('replaceRange');
					/* HERE IS BUG MAYBE - IT INSERST FILE TREE ON START OF FILE */ 
					var content_before 	= file_content.substring( 0,	update_pos.start );
					var content_after	= file_content.substring( update_pos.end,	koEditor.getLength() );				
					
					koEditor.setValue( content_before + content_update + '\n' );
					koEditor.goDocEnd();
					
					var end_of_range	= koEditor.getCursorPosition('absolute');
					koEditor.insert(content_after);
					koEditor.setCursor(end_of_range-1);
				};
				
				/** insertContent
				 */
				var insertContent = function()
				{
					/** goToInsertPosition
					 */
					var goToInsertPosition = function()
					{
						var line_content = koEditor.getLine( koEditor.getLineNumber() );
						
						if( ! line_content.match(/^\s*$/gi)  )
							koEditor.goLineEnd();
							//scimoz.newLine();
						else
							koEditor.goLineStart();
							
						//scimoz.newLine();
					};
					
					goToInsertPosition();
					
					//koEditor.insert( '\n'+ content_update );
					/*------ UPDATE CONTENT IN KOMODO ------*/
					koEditor.insert( '```\n'+ content_update +'\n```' );
                };

			var content_update	= getHeadings() + include_lines.join('\n') + '\n';
			
			var update_pos	= getUpdatePosition();
	
				if( update_pos && heading!=='' )
					replaceRange(update_pos);				
				else
					insertContent();
				
			};
			
			if( ! include_lines.length  )
				return;

			ko.views.manager.currentView.scimoz.beginUndoAction();
			
			try {
				
				_updateContent();
				
			} finally {
				ko.views.manager.currentView.scimoz.endUndoAction();
			} 
		}; 
		
		initialized = true;
	}
	
	return MarkdownLinker;
  
})();